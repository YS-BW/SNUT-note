# 1. 绪论


## 1.1 基础概念
###  1.1.1 四个基本概念

- 数据:用于记录或标识事物特性和物理状态的一串物理符号,是表达和传递信息的工具
  - 数据处理:将数据转化为信息的过程
  - 信息与数据的关系
    - 信息滞后于数据
    - 数据客观,信息主观
    - 数据是结构化的描述形式
    - 信息常常是半结构化或者非结构化
- 数据库:长期存储在计算机内,有组织的,可共享,统一管理的数据集合
- 数据库管理系统(Data Base Management System,DBMS):是建立,管理,维护和控制数据库的计算机系统软件
  - 作用:
    - 数据定义功能(DDL)
    - 数据操纵功能(DML)
    - 数据库的运行管理与控制功能(DCL)
    - 数据组织,存储和管理功能
    - 数据库建立和维护功能
    - 数据接口
- 数据库系统(Database System,DBS):管理和控制数据库功能的计算机系统

![image-20250607154713123](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607154713123.png)

## 1.2 数据库系统的结构✨✨✨

- **数据库系统与文件系统的主要区别是**:
  - **文件系统不能解决数据冗余和数据独立性问题，而数据库系统可以解决**✨

### 1.2.1 内部体系结构

- 数据库的**三级模式**结构✨✨✨
  - 外模式(子模式) == 用户模式:
    - **一个数据库有多个外模式**
    - **一个应用有一个外模式**
    - 数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述
    - 数据库用户的数据视图,是与某一应用有关的数据的逻辑表示
    - 介于模式与应用之间
    - **模式与外模式的关系:一对多(是模式的子集)**
    - 具有安全保护的功能
  - (概念)模式 == 逻辑模式:
    - 数据库中全体数据的逻辑结构和特征描述
    - 是所有用户的公共数据视图
    - **一个数据库只有一个模式**
    - 模式与物理存储和硬件无关
    - 与具体的程序和开发环境也无关
  - 内模式(存储模式) == 物理模式:
    - 是数据物理结构和存储方式的描述
    - 是数据在数据库内部的表示方式
    - **一个数据库只有一个内模式**

![image-20250607155754925](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607155754925.png)

- **两级映像**✨✨✨
  - 外模式/模式映像:实现逻辑独立性(表结构变化不影响应用)
  - 模式/内模式映像:实现物理独立性(存储方式变化不影响逻辑结构)

## 1.3 数据模型

**是对现实世界数据特征的抽象**

- 概念模型
- 逻辑模型和物理模型
  - 逻辑模型
    - 层次模型(一颗倒立的树)
      - 有且仅有一个节点,无父节点
      - 其他节点仅有一个父节点
    - 网状模型(一个网络状)
      - 允许一个以上的节点无父节点
      - 允许节点有多个父节点
  - 物理模型
- 组成
  - 数据结构
  - 数据操纵
  - 完整性约束条件
- 常用数据模型
  - 层次模型
  - 网状模型
  - 关系模型
  - 面相对象数据模型
  - 对象关系数据模型
  - 半结构化数据模型

### 1.3.1 概念模型

**用于信息世界的建模,是现实世界到机器世界的一个中间层次**

- 相关概念
  - 实体:具体的人或物
  - 属性:实体具有的特性
  - 码:唯一标识实体的属性集
  - 实体型:用实体名和属性名集合来抽象刻画同类实体
    - 学生(姓名,年龄,学号)
  - 实体集:同一类型的实体集合
  - 联系:实体与属性,实体与实体
    - 一对一
    - 一对多
    - 多对多

- 描述方式
  - 实体-联系方法(E-R图)

​	![image-20250607172440124](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607172440124.png)

### 1.3.2层次模型

- 条件
  - 有且只有一个结点没有双亲节点,这个结点叫做根节点
  - 根以为的其他结点有且只有一个双亲结点

![image-20250607172959821](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607172959821.png)

- 特点
  - 双亲唯一
  - 只能处理一对多
- 数据操纵
  - 查询
  - 插入
  - 删除
  - 更新

### 1.3.3 网状模型

- 条件
  - 允许一个以上的节点无双亲
  - 一个节点可以有多个双亲

![image-20250607174020097](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607174020097.png)

- 完整性约束条件
  - 码:唯一标识巨鹿的数据项的集合
  - 一个联系中双亲与子女是一对多
  - ....
- 优缺点
  - 优点
    - 符合现实世界,可以一对多
    - 性能良好,存取效率高
  - 缺点
    - 结构复杂
    - DDL,DML语言复杂

### 1.3.4 关系模型✨✨✨

**关系模型中数据的逻辑结构是一张二维表,由行和列组成**

- 相关概念

  - 关系:一个表

  - 元组:一行

  - 属性:一列

  - 主码:可以唯一确定一个元组的属性组

  - 域:相同属性类型的值的集合

  - 分量:元组中的一个属性值

    ![image-20250607174636066](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607174636066.png)

- 实体和实体型之间的联系的表示方法
  - 实体型
  - 属性
  - 一对一,一对多
  - 多对多

- 关系的规范条件:关系不能存在表中还有表,必须不可分

![image-20250607175019583](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607175019583.png)

- 操纵与完整性约束
  - 操纵
    - 查询
    - 插入
    - 删除
    - 更新
  - **完整性约束**✨✨✨
    - **实体完整性**
    - **参照完整性**
    - **用户定义完整性**

## 1.4 数据库系统的组成

- 数据库（Database)
- 数据库管理系统（DBMS）(核心)
- 应用程序（Application Programs）
 应用程序是为特定业务需求开发的软件
- 用户（Users）
 包括最终用户、数据库管理员（DBA）和应用程序开发人员。最终用户通过应用程序或查询工具访问数据，DBA负责数据库的设计、维护和权限管理。

(**操作系统与硬件**：数据库系统依赖底层操作系统和硬件支持，包括存储设备、处理器和网络设施，用于数据存储和高效访问。)

![image-20250607181152019](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607181152019.png)
# 10 并发控制

## 10.1 概述

- 事务是并发控制的基本单位
- 并发控制机制的任务✨
	- 对并发操作进行正确调度
	- 保证事务的隔离性
	- 保证数据库的一致性
- 记号
	- R（X）：读数据
	- W（X）：写数据
- 并发操作带来的数据不一致性✨
	- 丢失修改（抢火车票）
	- 不可重复读（T2操作数据）
	- 读“脏数据“(与数据库数据不一致)
## 10.2 封锁与封锁协议
- 基本封锁类型✨
	- 排他锁(写锁，X锁)
		> 上厕所的门锁
		
	- 共享锁 (读锁,S锁)
		> ATM机取钱，可看不可用
- (三级)封锁协议✨
	- 一级封锁协议
		- 使用X锁
		- 防止了丢失数据
	- 二级封锁协议
		- 使用X后使用S锁，事务结束释放X，操作结束释放S
		- 防止在读脏数据
	- 三级封锁协议
		- 在读之前先使用S锁，结束后才能释放
		- 防止不可重复读
> 封锁协议越高，一致性越高
## 10.3 活锁和死锁
- 活锁：一直让插队，一直等不到
	- 避免方法：先来先到
- 死锁：A锁住了B的钥匙，B锁住了A的钥匙
	- 预防：
		- 一次封锁法
			- 事务将要使用的数据一次性全部加锁
			- 降低了并发度
		- 顺序封锁法
			- 按规定的封锁顺序
			- 维护成本高，难以实现
	-  诊断死锁的方法
		- 超时法：超过时间就解开
		- 等待图法
	- 并发控制子系统的解决办法
		- 选择一个代价最小的事务，将其撤销，使其他事务继续运行下去
## 10.4 并发调度的可串行性
**一个并发调度，当前仅当他是可串行化的，才认为是正确调度**
- 冲突操作
	- RI(X)&WJ(X)
	- WI(X)&WJ(X)
> 发生冲突操作则不能可串行化
## 10.5 两段锁协议
**两段锁协议可以实现并发调度的可串行性**（充分条件）
- 所以事务必须分两个阶段对数据项加锁和解锁
	- 在对任何数据读写之前要获得对该数据的封锁
	- 在释放一个锁之后，不能申请和获得其他锁
	- 两个阶段
		- 获得锁
		- 释放锁# 2. 关系数据库

## 2.1 关系--关系模式的数据结构

- 域:相同数据类型的集合

- 笛卡尔积:
  $$
  R \times S = \{ (r, s) \mid r \in R, s \in S \} \
  $$
  ![image-20250607202401725](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607202401725.png)

- 基数: 关系包含的元组个数

  - 假设关系  S （课程表：课程号，课程名）包含 2 个元组：
    $$
    S = \{(C1, 数学), (C2, 英语)\}
    $$
    例:

    ![image-20250607203024398](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250607203024398.png)

- 关系:
  $$
  R \subseteq D_1 \times D_2 \times \dots \times D_n
  $$

  - R:关系名
  - n:关系的目或者度

- 单元关系与二元关系

  - n = 1:一元关系
  - n = 2:二元关系

- 元组:关系中的每个元素,通常用t表示

- 关系的表示:关系也是一个二维表,行对应元组,列对应域

- 属性:

  - 不同列对于不同域
  - 每一列取一个名字,叫做域
  - n目关系必须有n个列

- 码:

  - 候选码:一个属性就能确定一个元组
  - 全码:所以属性都有才能确定一个元组
  - 主码:存在多个候选码,选其中一个作为主码
  - 主属性:候选码的诸属性
  - 非主属性非(非码属性):不包含在任何候选码中的属性

- 三类关系(三类表):
  - 基本关系(基本表或基表):实际存在的表,是存储数据的逻辑表示
  - 查询表:查询结果对应的表
  - 视图表:有基本表或其他视图表导出的表,是虚表,不对呀实际存储的数据

- 基本关系的性质
  - 列同质
  - 不同列可以出自同一域
  - 行列的顺序无所谓
  - 任意两元组候选码不能相同,相同则为重复元组
  - **分量必须不可分**

## 2.2 关系模式及关系数据库

### 2.2.1 关系模式

- 关系模式:
  $$
  R(A, U, DOM, F)
  $$

  - R:关系名
  - U:组成该关系的属性名集合
  - D:U中属性所来自的域
  - DOM:属性向域的映像集合
  - F:属性之间数据的依赖关系的集合
  - 或表示为:

  $$
   R(A_1, A_2, \dots, A_n) 
  $$

  - R:关系名
  - A:属性名

- 关系与关系模式的联系

  - 参考面向对象,关系模式类似于对象(抽象的,不可变的)
  - 而关系类似于实现类(具体的,可变的)

### 2.2.2 关系数据库

**形式化描述：关系数据库由一组关系模式及其对应的关系实例组成，遵循关系模型的结构、操作和完整性约束。**

## 2.3 关系操纵

- 两种类型
  - 查询操纵(5种基本操作)
    - 选择
    - 投影
    - 并
    - 差
    - 笛卡尔积
  - 数据更新
    - 插入
    - 删除
    - 修改

- 特点
  - 操作对象都是集合

- 关系数据库语言的分类
  - 关系代数
  - 关系演算
    - 元组关系演算
    - 域关系演算
  - SQL语言

## 2.4 关系完整性

- 实体完整性(必须)

  - 主属性(主码中的属性)不能取空值

- 参照完整性(必须)

  - 引用的主码必须完整存在

    > 学生(学号[主码],课程号[外码])[参照关系]
    >
    > 课程(课程号[主码],课程名)[被参照关系]
    >
    > **学生所包含的课程号,必须是确实存在的课程**

- 用户定义完整性

  - 符合实情况的约束

    > 性别只能是男或女

## 2.5 关系代数

- 五种基本运算✨✨✨
  - 并
  - 差
  - 笛卡尔积
  - 选择
  - 投影

### 2.5.1 传统集合运算

- 并

  - $$
     R \cup S = \{ t \mid t \in R \lor t \in S \} 
    $$

    

- 差

  - $$
     R - S = \{ t \mid t \in R \land t \notin S \} 
    $$

    

- 交

  - $$
     R \cap S = \{ t \mid t \in R \land t \in S \} 
    $$

    

- (广义)笛卡尔积

  - $$
    R \times S = \{ (r, s) \mid r \in R, s \in S \} 
    $$

    

### 2.5.2 专门的关系运算✨✨✨

- 选择

  - $$
    \sigma_{条件}(R) = \{ t \mid t \in R \land 条件(t) \}
    $$
	
	> $$
	> \begin{array}{ |c|c|c| }
	> \hline
	> Sno & Sname & Sdept \\
	> \hline
	> 001 & 张三 & 计算机 \\
	> 002 & 李四 & 数学 \\
	> \hline
	> \end{array}
	> $$
	> 
	>
	
	> $$
	> 
	> $$
	> $$
	> \sigma_{Sdept='计算机'}(Student) = \{(001, 张三, 计算机)\}
	> \
	> $$
	>
	> 
	
- 投影

  - $$
    \pi_{A_1, A_2, \dots, A_k}(R) = \{ t[A_1, A_2, \dots, A_k] \mid t \in R \}
    $$

    > $$
    > \pi_{Sname}(Student) = \{(\text{张三}), (\text{李四})\}
    > $$
    >
    > 

- 连接

  - - 等值连接

      - $$
        R \bowtie_{R.A=S.B} S = \sigma_{R.A=S.B}(R \times S)
        $$
  
        ![image-20250608153915388](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250608153915388.png)
  
  ​	 
  
  - 自然连接
  
    - $$
      R \bowtie S = \{ t \mid t[A] \in R, t[B] \in S, t[A \cap B] = t[A] \cap t[B] \}
      $$
      
      ![image-20250608154000120](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250608154000120.png)
  
    > 外连接:
    >
    > ![image-20250608154241393](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250608154241393.png)

- 除

  - $$
    R \div S = \{ t[A] \mid t \in R, \forall s \in S, (t[A], s[B]) \in R \}
    $$

    - > $$
      >  R(Sno, Cno) = \{(001, C1), (001, C2), (002, C1)\} ,
      > S(Cno) = \{(C1), (C2)\} 
      > $$
      >
      > 

      > $$
      > R \div S = \{(001)\}
      > $$
      >
      > 

![image-20250608154732762](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250608154732762.png)

# 3. SQL语言

## 3.1 SQL概述

![image-20250608165310222](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250608165310222.png)

- SQL支持数据定义（DDL）、数据操作（DML）、数据控制（DCL）等多种功能。

- SQL是结构化查询语言✨

- 非过程化语言✨

- 关系数据库语言✨

- 使用方式✨

  - 交互式SQL

  - 嵌入式SQL

- 组成部分

  | 分类 | 全称                       | 说明                                                         |
  | :--- | -------------------------- | ------------------------------------------------------------ |
  | DDL  | Data Definition Language   | 数据定义语言,用来定义数据库对象(数据库,表,字段)建立三级模式✨ |
  | DML  | Data Mainpulation Language | 对表中数据进行增删改的语言                                   |
  | DQL  | Data Query Language        | 用来查询数据的语言                                           |
  | DCL  | Data Control Language      | 创建用户和控制用户权限的语言                                 |

- 与关系代数/关系演算的比较:

  - 关系代数：基于集合操作，理论性强，如
    $$
    \sigma、\pi、\bowtie
    $$

  - 元组关系演算：基于逻辑，描述查询条件。

  - SQL：综合两者优点，语法简洁，易于使用。

## 3.2 数据定义

| 操作 | 创建          | 删除        | 修改        |
| ---- | ------------- | ----------- | ----------- |
| 模式 | CREATE SCHEMA | DROP SCHEMA |             |
| 表   | CREATE TABLE  | DROP TABLE  | ALTER TABLE |
| 视图 | CREATE VIEW   | DROP VIEW   |             |
| 索引 | CREATE INDEX  | DROP INDEX  | ALTER INDEX |



### 3.2.1 基本表的定义

- 表的定义

  - 创建

    - ```sql
      CREATE TABLE Student (
          SNO CHAR(10) PRIMARY KEY,
          SNAME VARCHAR(50),
          AGE INT,
          SEX CHAR(2)
      );
      ```

      > 创建学生表，SNO  为主码，定义属性及其数据类型。

  - 修改

    - ```sql
      ALTER TABLE Student ADD COLUMN SDEPT VARCHAR(50);
      ```

      > 为学生表添加院系（SDEPT）列。

  - 删除

    - ```sql
      DROP TABLE Student;
      ```

      > 删除学生表（注意：操作不可逆，需谨慎使用）。

### 3.2.2 索引

**目的:加快查询速度,非必需**

- 创建索引

  - ```sql
    CREATE INDEX idx_sname ON Student(SNAME);
    ```

- 删除索引

  - ```sql
    DROP INDEX idx_sname;
    ```

- 修改索引

  - ```sql
    ALTER INDEX idx_sname REBUILD;
    ```

  

## 3.3 数据查询

```sql
SELECT 字段列表
FROM 表名列表
WHERE 条件列表
GROUP BY 分组字段列表
HAVING 分组后条件列表
ORDER BY 排序字段列表
LIMIT 分页参数
```

- employee 表结构与数据
  以下是示例使用的 `employee` 表结构和部分数据（为简洁，仅展示表结构和前几条数据，完整数据包含 20 条记录）。
  - 表结构

```sql
CREATE TABLE employee (
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT '编号',
    workno VARCHAR(10) NOT NULL COMMENT '工号',
    name VARCHAR(10) NOT NULL COMMENT '姓名',
    gender CHAR(1) COMMENT '性别',
    age TINYINT UNSIGNED COMMENT '年龄',
    idcard VARCHAR(18) COMMENT '身份证号',
    workaddress VARCHAR(100) COMMENT '工作地址',
    entrydate DATE COMMENT '入职日期'
);
```

- 插入数据（示例）
```sql
INSERT INTO employee (workno, name, gender, age, idcard, workaddress, entrydate) VALUES
    ('W001', '张伟', 'M', 30, '110101199312010001', '北京市朝阳区建国路1号', '2020-05-10'),
    ('W002', '李娜', 'F', 28, '110101199512150002', '北京市海淀区中关村2号', '2021-03-15'),
    ('W003', '王磊', 'M', 35, '110101199006200003', '上海市浦东新区张江路3号', '2019-11-01'),
    -- 以下省略，完整数据包含 20 条记录
    ('W020', '马丽', 'F', 29, '110101199604150020', '北京市丰台区南四环20号', '2021-05-29');
```

### 基本查询
1. **查询多个字段**  
   ```sql
   SELECT 字段1, 字段2, 字段3 FROM 表名;
   SELECT * FROM 表名;
   ```
2. **设置别名**  
   ```sql
   SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] FROM 表名;
   ```
3. **去重**  
   ```sql
   SELECT DISTINCT 字段列表 FROM 表名;
   ```

- 示例
```sql
-- 查询工作地址、编号和姓名
SELECT workaddress, id, name FROM employee;

-- 查询所有字段
SELECT * FROM employee;

-- 设置别名（工作地址）
SELECT workaddress AS '工作地址' FROM employee;

-- 简写别名（不推荐，易混淆）
SELECT workaddress '工作地址' FROM employee;

-- 查询工作地址去重
SELECT DISTINCT workaddress FROM employee;
```

### 条件查询
**语法**  
```sql
SELECT 字段列表 FROM 表名 WHERE 条件列表;
```

#### SQL 条件符号
1. **比较运算符**  
   - `=`：等于  
   - `!=` 或 `<>`：不等于  
   - `>`：大于  
   - `<`：小于  
   - `>=`：大于或等于  
   - `<=`：小于或等于  

2. **逻辑运算符**  
   - `AND`：与（多个条件同时满足）  
   - `OR`：或（任一条件满足）  
   - `NOT`：非（条件取反）  

3. **其他常用条件符号/操作**  
   - `LIKE`：模糊匹配  
     - `%`：任意长度的字符  
     - `_`：单个字符  
   - `IN`：匹配列表中的任意值  
   - `BETWEEN ... AND ...`：匹配范围（包含边界）  
   - `IS NULL`：判断值是否为空  
   - `IS NOT NULL`：判断值是否非空  

- 示例
```sql
-- 查询年龄等于 30 的员工
SELECT * FROM employee WHERE age = 30;

-- 查询年龄小于等于 30 的员工
SELECT * FROM employee WHERE age <= 30;

-- 查询编号非空的员工
SELECT * FROM employee WHERE id IS NOT NULL;

-- 查询年龄不等于 30 的员工
SELECT * FROM employee WHERE age != 30;

-- 查询年龄在 25 到 30 岁之间的员工
SELECT * FROM employee WHERE age BETWEEN 25 AND 30;

-- 查询男性且年龄在 25 到 30 岁的员工
SELECT * FROM employee WHERE gender = 'M' AND age BETWEEN 25 AND 30;

-- 查询年龄为 25、30 或 45 的男性员工
SELECT * FROM employee WHERE gender = 'M' AND age = 30 OR age = 25 OR age = 45;

-- 查询年龄在 28、30、45 的员工
SELECT * FROM employee WHERE age IN (28, 30, 45);

-- 查询姓名长度为 2 个字符的员工
SELECT * FROM employee WHERE name LIKE '__';

-- 查询编号以 3 结尾的员工
SELECT * FROM employee WHERE id LIKE '%3';

-- 查询年龄在 30 到 33 岁的员工
SELECT * FROM employee WHERE age IN (30, 31, 32, 33);

-- 查询女性、年龄在 20 到 40 岁、姓名长度为 2 的员工
SELECT * FROM employee WHERE age BETWEEN 20 AND 40 AND gender = 'F' AND name LIKE '__';
```

### SQL 聚合函数
**介绍**：将一列数据作为一个整体，进行纵向计算  

#### 常用聚合函数
- `COUNT()`：统计行数  
  - `COUNT(*)`：统计所有行（包括 NULL）  
  - `COUNT(列名)`：统计指定列非 NULL 的行数  
- `SUM(列名)`：计算数值总和  
- `AVG(列名)`：计算平均值  
- `MAX(列名)`：获取最大值  
- `MIN(列名)`：获取最小值  

> 注意事项
- 聚合函数忽略 `NULL` 值（`COUNT(*)` 除外）。  
- 常与 `GROUP BY` 结合，按指定列分组后进行汇总。  
- 可与 `HAVING` 配合，筛选分组后的结果。  

- 示例
```sql
-- 统计员工总数
SELECT COUNT(*) FROM employee;

-- 统计身份证号非空的员工数
SELECT COUNT(idcard) FROM employee;

-- 计算平均年龄
SELECT AVG(age) FROM employee;

-- 查找最大年龄
SELECT MAX(age) FROM employee;

-- 查找最小年龄
SELECT MIN(age) FROM employee;

-- 计算西安地区员工的年龄总和
SELECT SUM(age) FROM employee WHERE workaddress LIKE '西安%';
```

### 分组查询
**语法**  

```sql
SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];
```

#### `WHERE` 和 `HAVING` 的区别
- **执行时间**：`WHERE` 在分组之前，`HAVING` 在分组之后。  
- **判断条件**：`WHERE` 不能对聚合函数进行判断，`HAVING` 可以。  
- **执行顺序**：`WHERE` > 聚合函数 > `HAVING`  
- **注意**：分组后，查询字段一般为聚合函数和分组字段，其他字段无意义。  

- 示例
```sql
-- 按性别分组，统计人数
SELECT gender, COUNT(*) FROM employee GROUP BY gender;

-- 按性别分组，计算平均年龄
SELECT gender, AVG(age) FROM employee GROUP BY gender;

-- 按工作地址分组，统计人数（年龄 < 45，人次 >= 3）
SELECT workaddress, COUNT(*) FROM employee 
WHERE age < 45 
GROUP BY workaddress 
HAVING COUNT(*) >= 3;

-- 按性别分组，统计年龄小于 30 的员工人数
SELECT gender, COUNT(*) FROM employee 
WHERE age < 30 
GROUP BY gender;
```

### 排序查询
**语法**  
```sql
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;
```

#### 排序方式
- `ASC`：升序（默认）  
- `DESC`：降序  
- **注意**：多字段排序时，若第一个字段值相同，则按第二个字段排序。  

- 示例
```sql
-- 按年龄升序排序
SELECT * FROM employee ORDER BY age ASC;

-- 按年龄升序排序（默认）
SELECT * FROM employee ORDER BY age;

-- 按年龄降序排序
SELECT * FROM employee ORDER BY age DESC;

-- 按入职日期降序排序
SELECT * FROM employee ORDER BY entrydate DESC;

-- 按入职日期升序排序
SELECT * FROM employee ORDER BY entrydate ASC;

-- 按年龄升序、入职日期降序排序
SELECT * FROM employee ORDER BY age ASC, entrydate DESC;

-- 查询年龄小于 35 的员工，按年龄和入职日期排序
SELECT name, age FROM employee 
WHERE age < 35 
ORDER BY age, entrydate DESC;

-- 查询男性、年龄 20-50 岁的员工，按年龄和入职日期排序，前 5 条
SELECT * FROM employee 
WHERE gender = 'M' AND age BETWEEN 20 AND 50 
ORDER BY age, entrydate DESC 
LIMIT 5;
```

### 分页查询
**语法**  
```sql
SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;
```

> 注意事项
- 起始索引从 0 开始，计算公式：`(查询页码 - 1) * 每页记录数`  
- MySQL 使用 `LIMIT`，其他数据库可能不同（如 SQL Server 用 `TOP`）。  
- 查询第一页时，起始索引可省略，如 `LIMIT 10`。  

- 示例
```sql
-- 查询第 1 页，每页 10 条
SELECT * FROM employee LIMIT 0, 10;

-- 查询前 10 条（第一页简写）
SELECT * FROM employee LIMIT 10;

-- 查询第 2 页，每页 10 条
SELECT * FROM employee LIMIT 10, 10;
```

## 3.4 数据更新

- 插入
1. **给指定字段添加数据**  
   
   ```sql
   INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);
   ```
2. **给全部字段添加数据**  
   
   ```sql
   INSERT INTO 表名 VALUES (值1, 值2, ...);
   ```
3. **批量添加数据**  
   - 指定字段：  
     ```sql
     INSERT INTO 表名 (字段名1, 字段名2, ...) 
     VALUES (值1, 值2, ...), (值1, 值2, ...), ...;
     ```
   - 全部字段：  
     ```sql
     INSERT INTO 表名 
     VALUES (值1, 值2, ...), (值1, 值2, ...), ...;
     ```



- 修改(DML)

```sql
UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件];
```

> ```sql
> -- 修改工号为 W021 的员工年龄为 28
> UPDATE employee SET age = 28 WHERE workno = 'W021';
> 
> -- 修改北京市员工的工作地址为“北京市朝阳区新地址”
> UPDATE employee 
> SET workaddress = '北京市朝阳区新地址' 
> WHERE workaddress LIKE '北京市%';
> 
> -- 同时修改姓名和入职日期
> UPDATE employee 
> SET name = '赵丽丽', entrydate = '2023-07-01' 
> WHERE workno = 'W021';
> 
> -- 清空某字段值（设为 NULL，非 NOT NULL 字段）
> UPDATE employee 
> SET idcard = NULL 
> WHERE workno = 'W023';
> ```



- 删除

  ```sql
  DELETE FROM 表名 [WHERE 条件];
  ```

  > ```sql
  > -- 删除工号为 W021 的员工
  > DELETE FROM employee WHERE workno = 'W021';
  > 
  > -- 删除年龄大于 35 的员工
  > DELETE FROM employee WHERE age > 35;
  > 
  > -- 删除入职日期早于 2020 年的员工
  > DELETE FROM employee WHERE entrydate < '2020-01-01';
  > 
  > -- 删除整张表数据（谨慎使用）
  > DELETE FROM employee;
  > ```

## 3.5 视图

- 特点

  - 虚表,从一个或几个**基本表**或**视图**导出的表✨
  - 只存视图的定义,不存数据✨
  - 数据变化,视图变化

- 建立视图

  - ```sql
    CREATE VIEW <视图名>[(列名)(列名)]AS<子查询>
    ```

- 删除视图

  - ```SQL
    DROP VIEW <视图名>[CASCADE];
    ```

- 优点

  - 提高数据的逻辑独立性✨

## # 4. 数据库安全性

## 4.1 概述

- 定义
  - 数据库的安全性问题是指保护数据库免受未经授权的访问、篡改、泄露或破坏，确保数据机密性、完整性和可用性的能力。✨
  
- 主要措施
  - 用户身份鉴别
  - 存取控制
  - 视图

- 安全标准

  - TCSEC
  - CC

- 常用方法和技术

  ##### 权限

  - 用户认证
    - **描述**：验证用户身份，通常通过用户名和密码。
    - **技术**：支持多因素认证（如密码+动态码）。
  - 权限管理
    - **描述**：为用户或角色分配特定操作权限（如SELECT、INSERT）。
    - **技术**：基于角色的访问控制（RBAC），如GRANT、REVOKE语句。

  ##### 数据加密

  - 存储加密
    - **描述**：对存储在磁盘上的数据进行加密，防止物理盗窃。
    - 分类
      - 透明存储加密(性能好,安全性高)
      - 非透明存储加密
  - 传输加密
    - **描述**：对数据在网络中的传输进行加密。
    - 分类
      - 链路加密
      - 端到端加密
  
  ##### 审计与日志
  
  - 操作审计
    - **描述**：记录用户对数据库的所有操作。
    - **技术**：日志文件或审计表，定期分析异常行为。
  - 入侵检测
    - **描述**：实时监控并检测潜在安全威胁。
    - **技术**：基于规则或机器学习的入侵检测系统。
  
  ##### 备份与恢复
  
  - 数据备份
    - **描述**：定期创建数据库副本。
    - **技术**：全量备份、增量备份。
  - 灾难恢复
    - **描述**：在数据丢失或损坏时恢复数据库。
    - **技术**：恢复点和恢复时间目标（RPO/RTO）策略。
  
  

## 4.2 安全性控制

### 4.2.1 存取控制与授权

#### 授权

- 授权:定义权限✨

- ```sql
  GRANT SELECT ON Student TO user1;#授权✨
  REVOKE INSERT ON Student FROM user1;#收回✨
  ```

- 创建数据库模式权限

  - ![image-20250609145803001](D:\临时\image-20250609145803001.png)

#### 存取控制机制

- 组成

  - 定义权限,登记到字典
  - 权限检查

- 常用方法✨

  - 自主存取控制(DAC)[灵活]
    - 通过SQL的`GRANT`和`REVOKE`实现
    - 权限组成
      - 数据对象
      - 操作类型
  - 强制存取控制(MAC)
    - 特点
      - 安全性高
      - 用户不能直接感知或控制
      - 适用于对数据有严格密级分类的部门
    - 敏感度标记
      - 绝密(TS)
      - 机密(S)
      - 可信(C)
      - 公开(P)
      - TS>=S>=C>=P
    - 存取规则
      - 仅当主体的许可证级别**>=**客体的密级时,才能读取
      - 仅当主体的许可证级别**<=**客体的密级时,才能写入
      - ![image-20250609150715557](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250609150715557.png)

  

### 4.2.2 数据库角色

**角色是权限的集合**

- 创建

  - ```sql
    CREATE ROLE<角色名>
    ```

- 授权

  - ```sql
    GREANT <权限> ON <对象类型> TO <角色>
    ```

- 授予

  - ```sql
    GRANT <角色1> TO <角色2>/<用户1>[WITH ANMIN OPTION]
    ```

- 回收

  - ```sql
    REVOKE <权限> ON <对象类型><对象名字> FROM <角色>
    ```



# 5. 数据库完整性

**数据的正确性和相容性**✨

- 与安全性的区别和联系✨

  - 数据的完整性✨
    - 防止数据库中存在不符合语义的数据,也就是防止数据库中存在不正确的数据
    - 防范对象:不合语义的、不正确的数据
  - 数据的安全性✨
    - 保护数据库防止恶意的破坏和非法的存取
    - 防范对象:非法用户和非法操作

	- > 完整性是阻止合法用户通过合法操作向数据库中加入不正确的数据
  	> 安全性防范的是非法用户和非法操作存取数据库中的正确数福
- RDBMS完整性机制的组成部分
  - 定义机制
  - 检查机制
  - 违约机制

## 5.1 实体完整性(主键约束)

- 定义

  - ```SQL
    # 列级定义主码
    CREATE TABLE Student (
        SNO CHAR(10) PRIMARY KEY,
        SNAME VARCHAR(50) NOT NULL,
        AGE INT
    );
    ```

  - ```sql
    # 表级定义主码
    CREATE TABLE SC (
        SNO CHAR(10),
        CNO CHAR(10),
        GRADE INT,
        PRIMARY KEY (SNO, CNO)/*两个以上只能用表级别*/
    );
    ```

  | 操作类型   | 可能违反实体完整性的场景           | 违约处理方式 |
  | ---------- | ---------------------------------- | ------------ |
  | 插入元组   | 主键为空值（NULL）                 | 拒绝         |
  | 插入元组   | 主键值与已存在记录重复             | 拒绝         |
  | 修改主键值 | 修改后的主键值与已存在记录重复     | 拒绝         |
  | 修改主键值 | 将主键值修改为 NULL                | 拒绝         |
  | 删除元组   | 删除后导致表无主键（通常不会发生） | 允许         |

## 5.2 参照完整性(外键约束)

- 定义

  - ```sql
    -- 父表：Courses（课程）
    CREATE TABLE Courses (
        course_id INT,
        semester INT,
        course_name VARCHAR(50) NOT NULL,
        PRIMARY KEY (course_id, semester)
    );
    
    -- 子表：Enrollments（选课记录）
    CREATE TABLE Enrollments (
        student_id INT,
        course_id INT,
        semester INT,
        grade DECIMAL(3,1),
        PRIMARY KEY (student_id, course_id, semester),
        -- 复合外键：同时关联 Courses 的两个列
        FOREIGN KEY (course_id, semester) REFERENCES Courses(course_id, semester)
    );
    ```

    

| 被参照表（例如Student） | 参照表（例如SC）   | 违约处理                 |
| ----------------------- | ------------------ | ------------------------ |
| 可能破坏参照完整性      | 插入元组           | 拒绝                     |
| 可能破坏参照完整性      | 修改外码值         | 拒绝                     |
| 删除元组                | 可能破坏参照完整性 | 拒绝/级连删除/设置为空值 |
| 修改主码值              | 可能破坏参照完整性 | 拒绝/级连修改/设置为空值 |

## 5.3 用户定义完整性(应用约束)

- 属性上的约束条件

  - 非空(NOT NULL)
  - 唯一(UNIQUE)
  - 检查是否满足表达式(CHECK)

  > ```SQL
  > CREATE TABLE employees 
  > (
  >  id INT,
  >  employee_number VARCHAR(20) UNIQUE[约束条件], 
  >  name VARCHAR(50)
  > )
  > ```

| 规则类型        | 作用对象（表/列）               | 触发操作           | 可能破坏完整性的场景                         | 违约处理方式                                   |
| --------------- | ------------------------------- | ------------------ | -------------------------------------------- | ---------------------------------------------- |
| CHECK 约束      | 单个/多个列（如学生表 `age`）   | 插入元组、修改列值 | 插入/修改后的值不满足条件（如 `age < 0`）    | 数据库拒绝操作，报错回滚                       |
| UNIQUE 约束     | 单个/复合列（如用户表 `email`） | 插入元组、修改列值 | 插入/修改后的值与已有唯一值重复              | 数据库拒绝操作，报错回滚                       |
| DEFAULT 约束    | 单个列（如订单表 `status`）     | 插入元组未显式赋值 | 业务需强制赋值但依赖默认值（如状态未自定义） | 按默认值填充（若业务强校验，需应用层补充拦截） |
| 自定义函数/规则 | 关联列（如金额表 `amount`）     | 插入元组、修改列值 | 违反自定义逻辑（如 `amount` 非 10 倍数）     | 数据库/应用层拒绝，报错回滚                    |

- 元组上的约束条件

  > ```sql
  > CREATE TABLE Students (
  >     student_id INT PRIMARY KEY,
  >     birth_year INT NOT NULL,
  >     enroll_year INT NOT NULL,
  >     -- 元组级约束：同一元组的 enroll_year ≥ birth_year
  >     CHECK (enroll_year >= birth_year)
  > );
  > ```

## 5.4 完整性约束命名子句

- ```sql
  CONSTRAINT [约束名] [约束条件]
  ```

```sql
CREATE TABLE employees (
    emp_id INT,
    dept_id INT,
    salary DECIMAL(10,2),
    -- 命名主键约束
    CONSTRAINT pk_employees PRIMARY KEY (emp_id),
    -- 命名外键约束
    CONSTRAINT fk_department 
        FOREIGN KEY (dept_id) REFERENCES departments(dept_id),
    -- 命名唯一约束
    CONSTRAINT uq_emp_salary UNIQUE (emp_id, salary)
);
```

## 5.5 触发器

**用户定义在关系表上的一类有事件驱动的特殊过程**

- 定义

- ```sql
  CREATE TRIGGER update_customer_order_count
  AFTER INSERT ON orders
  FOR EACH ROW
  BEGIN
    UPDATE customers
    SET total_orders = total_orders + 1
    WHERE customer_id = NEW.customer_id;
  END$$
  ```

- 只能定义在基本表上,不能定义在视图上

- 激活表时,自动激活触发器

# 6. 关系数据理论

- 问题提出
  - 数据冗余
  - 更新异常
  - 插入异常
  - 删除异常

- 数据依赖

  - 完整性约束的表现形式
  - 是一个关系内部属性与属性之间的一种约束关系,通过属性间值的相等与否体现出来的数据间相互联系
  - 是现实世界属性间相互联系的抽象
  - 是数据内在的性质
  - 是语义的体现
  - 主要类型
    - 函数依赖(FD)
    - 多值依赖(MVD)
    - 连接依赖

  ![image-20250610181302876](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250610181302876.png)

## 6.1 函数依赖,码,范式

#### 函数依赖

- 定义

  - 数据库中，若学生表学号确定则姓名唯一确定，此为函数依赖。

    > 学生表（学号，姓名）中，学号→姓名（学号决定姓名）。

*不是指唯一确定,指的是均要满足的条件*

- 如何确定

  - 根据语义

  > "姓名->年龄" 这个函数依赖只有在不允许同名的条件下成立

- 闭包( *X*+)✨

  - 所以依赖放在一起

  >  F = \{A→B, B→C, A→D\}
  >
  > {A\}^+ = \{A, B, C, D\}

- 最小函数依赖集：✨

  - 函数依赖左部最简（单属性）
  - 无冗余依赖（去掉后不影响推导）
  - 无冗余属性 

- 平凡函数依赖与非平凡函数依赖

  - 非平凡函数依赖

  > X->Y,但X⊉ Y X,则X->Y是非平凡函数依赖

  - 平凡函数依赖(必然成立)

  > X->Y,但X⊇Y,则X->Y是非平凡函数依赖

- 完全函数依赖与部分函数依赖✨

  - 完全函数依赖

    > X->Y,但是X的子集不可以

  - 部分函数依赖

    > X->Y,X的部分子集可以

- 传递函数依赖✨

  - 非主属性通过中间属性依赖主码

    > 如员工号→部门号→部门名


#### 码

-  **码**：唯一标识元组的属性或属性组。   
- **候选码**：最小码（无冗余属性），可唯一确定元组。   ✨
- **超码**：包含候选码的属性组（可能含多余属性）。   
- **主码**：从候选码中选定的一个作为主键，唯一标识记录。   
- **全码:** 整个属性组都是码
- **关系**：候选码是最小超码，主码是选中的候选码。
- **主属性**: 包含在任何一个候选码中的属性✨
- **非主属性:** 不包含在任何码中的属性✨

- **外部码:** 在一个关系中是码另一个关系中不是码

#### 范式✨✨✨

数据库设计中为避免数据冗余和异常的规范等级，分1NF、2NF、3NF等。  

- **1NF（第一范式）**  
  
  - **定义**：表中每个字段都是不可分割的原子值。(表里不能有表)  

  > 学生表中“地址”字段不能包含多个地址（如“北京,上海”），需拆分为“省”“市”等独立字段。  
  
- **2NF（第二范式）**  
  
  - **定义**：满足1NF，且非主属性完全依赖于主码（消除部分依赖）。  

  > 订单表（订单号,商品号,商品名,数量）中，“商品名”仅依赖“商品号”（部分依赖），需拆分为订单表和商品表。  
  
- **3NF（第三范式）**  
  - **定义**：满足2NF，且非主属性不传递依赖于主码（消除传递依赖）。  
  
  > 员工表（员工号,部门号,部门名）中，“部门名”通过“部门号”传递依赖“员工号”，需拆分为员工表和部门表。  
  
- **BCNF(BC范式)**
  
  - **定义:** 每一个属性都是(候选)码

  > SJP（S，J，P） 
  >
  >  函数依赖：`(S,J)→P`；`(J,P)→S`  
  >
  >  候选码：`(S,J)` 与 `(J,P)`（属性相交 ）
  >
  >  范式：`SJP ∈ 3NF` 且 `SJP ∈ BCNF`
  
- **核心目标**  

  - 减少数据冗余，提升增删改效率，确保数据一致性。

# 7. 数据库设计

## 7.1 概述

**对于给定的应用环境,构造(设计)优化的数据库逻辑模式和物理结构,并根据此建立数据库及其应用系统**

- **信息管理要求:**在数据库中应该存储和管理哪些数据对象
- **数据操作要求:**对数据对象进行哪些操作,如增,删,改,查询等
- **目的:** 为用户和各种应用系统提供一个信息基础设施和高效率的运行环境

#### 基本步骤和各级模式

- **6个阶段**

  - 需求分析
  - 概念结构设计
  - 逻辑设计
  - 物理设计
  - 数据库实验
  - 数据库运行和维护

  > 1. 需求分析和概念设计独立于任何数据库管理系统
  > 2. 逻辑设计和物理设计与选用的数据库管理系统密切相关

## 7.2 需求分析

- **目标:** 把用户提出的"要求"或"需要"进行分析与整理,确认人后形成描述完整、清晰与规范的文档,确定软件需要实现哪些当功能,完成哪些工作

- **重点:** "数据"和"处理"获得用户对数据库的要求

  

- **分析方法:** SA方法

- **数据字典:** 关于数据库中数据的描述,即元数据,不是数据本身,需要不断修改
  - 包括: 数据项(最小组成),数据结构,数据流,数据存储,处理过程

## 7.3 概念结构设计

**将需求分析得到的用户需求抽象为信息结构(即概念模型)的过程**

- 特点

  - 真实反映现实世界
  - 易于理解
  - 易于更改
  - 易于转换

- 描述概念模型的工具: **E-R模型**

- 方法

  - 自顶向下
  - 自底向上
  - 逐步扩张
  - 混合策略
  
  
  
  #### E-R模型
  
  **用ER图来描述现实世界的概念模型,包括实体、属性、实本之间的联系等**

- **实体与实体之间的联系**
  - 一对一
  - 一对多
  - 多对多

- **联系的度:** 参与联系的实体型的数目
  - 两个实体型之间的联系称为**二元联系**
  - N个实体型之间的联系称为**N元联系**

- **E-R图:**
  - 实体型:矩形,框内写实体名
  - 属性:椭圆形,和实体型连起来
  - 联系:菱形,和实体型连起来,同时表上类型(1:1,1:n或m:n)

![image-20250610225547701](C:\Users\32770\AppData\Roaming\Typora\typora-user-images\image-20250610225547701.png)# 9 数据库恢复技术

## 9.1 事务的基本概念

- 事务是数据库恢复和并发控制的基本单位
- 一个程序包含多个事务
- 定义语句
	- BEGIN TRANSACTION
	- COMMIT
	- ROLLBACK
	> BEGIN TRANSACTION
	> SQL语句1
	>SQL语句2
	> ...
	> COMMIT(提交) / ROLLBACK（回滚，终止，全部撤销）
	事务中的提交和回滚

- 提交（Commit）✨

	- 作用：将事务中所有操作永久保存到数据库，结束当前事务。
	- 特点：提交后的数据变更会被其他事务可见，且不可撤销。

- 回滚（Rollback）✨

	- 作用：撤销事务中所有未提交的操作，回退到事务开始前的状态，结束当前事务。
	- 特点：回滚后数据恢复原状，避免因错误操作导致数据不一致。

- 事务的ACID特性
	- 原子性
		- 逻辑工作单位
	- 一致性
		- 必须使一个状态转变为另一个状态
		- 如果数据库中只包含成功事务提交的结果，就说数据库处于一致性状态✨
	- 隔离性
		- 一个事物的执行不能被另一个事物干扰
	- 持续性（永久性）
		- 一旦提交就会发生永久的改变
		- DBMS的恢复子系统，保证了事务持久性✨
## 故障类型
- 故障的种类
	- 事务内部的故障
	- 系统故障
	- 介质故障
	- 计算机病毒
	- ....
- 系统故障
	- 特定类型的硬件错误
	- 操作系统故障
	- 数据库管理系统代码错误
	- 系统断电
	- 影响所以活跃事务
	- 缓冲区信息全部丢失
	- 不破坏数据库
	- 恢复
		- 撤销所以未完成的事务
		- 重做所以已提交的事务
		​￼- 介质故障
	- 磁盘损坏
	- 磁头碰撞
	- 瞬时强磁场干扰

￼- 恢复操作的基本原理
	- **冗余:** 利用存储在系统别处的冗余数据莱重建数据库中已破坏或不正确的那部分数据
## 9.3 恢复的实现技术
- 建立冗余数据
	- 数据转储（备份数据）
		- 静态转储与动态转储
			- 静态转储：无事物进行时
			- 动态转储：可以与事务并发进行
		- 海量转储：转储全部
		- 增量转储：转储更新过的
	- 登记日志文件
		- 格式和内容
			- 记录事务对数据库的更新操作的文件
			- 格式
				- 记录为单位
					- 事务标识
					- 操作类型
					- 操作对象
					- 旧值
					- 新值
				- 数据块为单位
					- 事务标识
					- 被更新的数据块
		- 作用
			- 进行故障恢复
		- 登记
			- 登记的次序严格按照时间次序
			- 先写日志文件，后修改数据库
## 9.4 恢复策略
- 事务故障
	- 利用日志撤销对数据库的修改
	- 由系统自动完成，不需要用户干预
- 系统故障
	- 撤销未完成的事务
	- 重做已完成的事务
	- 扫描三遍日遍日志文件
	- 由系统重新启动时自动完成，不需要用户干预
	​￼- 介质故障
	- 重装数据库
	- 重做已完成的事务
	- 
## 9.5 具有检查点的恢复技术
- 在日志文件中增加检查点记录
	- 检查点记录的内容
		- 检查点时刻所以正在执行的事务清单
		- 这些事务最近的一个日志记录的地址
- 增加重新开始文件
	- 每个检查点的地址
- 恢复子系统在登录日志文件期间动态维护日志
	- 将当前日志缓冲区的所有日志写入磁盘
	- 在日志文件写入检查点
	- 将数据缓冲区的数据记录写入磁盘的数据库
	- 将检查点记录在日志文件中的地址上写入一个重新开始文件
- 建立检查点的时间
	- 定期
		- 每隔一段时间
	- 不定期
		- 按照规则，如日志写满一半就建立
