# 10 并发控制

## 10.1 概述

- 事务是并发控制的基本单位
- 并发控制机制的任务✨
	- 对并发操作进行正确调度
	- 保证事务的隔离性
	- 保证数据库的一致性
- 记号
	- R（X）：读数据
	- W（X）：写数据
- 并发操作带来的数据不一致性✨
	- 丢失修改（抢火车票）
	- 不可重复读（T2操作数据）
	- 读“脏数据“(与数据库数据不一致)
## 10.2 封锁与封锁协议
- 基本封锁类型✨
	- 排他锁(写锁，X锁)
		> 上厕所的门锁
		
	- 共享锁 (读锁,S锁)
		> ATM机取钱，可看不可用
- (三级)封锁协议✨
	- 一级封锁协议
		- 使用X锁
		- 防止了丢失数据
	- 二级封锁协议
		- 使用X后使用S锁，事务结束释放X，操作结束释放S
		- 防止在读脏数据
	- 三级封锁协议
		- 在读之前先使用S锁，结束后才能释放
		- 防止不可重复读
> 封锁协议越高，一致性越高
## 10.3 活锁和死锁
- 活锁：一直让插队，一直等不到
	- 避免方法：先来先到
- 死锁：A锁住了B的钥匙，B锁住了A的钥匙
	- 预防：
		- 一次封锁法
			- 事务将要使用的数据一次性全部加锁
			- 降低了并发度
		- 顺序封锁法
			- 按规定的封锁顺序
			- 维护成本高，难以实现
	-  诊断死锁的方法
		- 超时法：超过时间就解开
		- 等待图法
	- 并发控制子系统的解决办法
		- 选择一个代价最小的事务，将其撤销，使其他事务继续运行下去
## 10.4 并发调度的可串行性
**一个并发调度，当前仅当他是可串行化的，才认为是正确调度**
- 冲突操作
	- RI(X)&WJ(X)
	- WI(X)&WJ(X)
> 发生冲突操作则不能可串行化
## 10.5 两段锁协议
**两段锁协议可以实现并发调度的可串行性**（充分条件）
- 所以事务必须分两个阶段对数据项加锁和解锁
	- 在对任何数据读写之前要获得对该数据的封锁
	- 在释放一个锁之后，不能申请和获得其他锁
	- 两个阶段
		- 获得锁
		- 释放锁